红黑树：     
对于叶子节点的下一个的结点，也就是叶子结点的下一个结点必须是黑色的    
这是为了满足，对于一个结点的每一条路径上的黑色结点的个数都应该是一样的     

主要：维护一个结点的所有路径上的黑色结点的个数是一个样的     
违反：每一个红色结点的下面必须是黑色的结点        

对于刚插入的红色结点不能让其变成黑色的结点        
注意：         
这里的叶子节点为什么不能使正常的叶子节点呢        
这是因为如果树有两个结点，一个黑结点，一个红结点，那么这个红结点就是叶子节点，这个时候就违反规则了，所以叶子节点必须是正常的叶子节点的下一个结点，也就是空节点         
总结：      
最长路径上的结点数不能超过最短路径上的结点数的二倍          
为什么又出现最长路径是最短路径的二倍呢？                     
这是因为会有这这样的一种情况：                  
对于一条链上所有的结点，都是按照一个黑结点和一个红结点进行穿插着链接的就会造成最长的路径是最短路径的二倍                  

红黑树插入删除的时候比AVL旋转的次数少(因为红黑树里面可以有红结点进行调节树的高度，不一定非要进行旋转，最长路径可以达到最短路径的二倍)         
    红黑树旋转的次数少，所以就可能比AVL更优，一般使用的都是红黑树，比如set，map底层都是使用红黑树进行实现的           

    插入：       
    插入红结点，改变一条路径，黑结点，改变所有的路径       
    插入的都是红结点，不会主动去插入黑结点                   
    1. 空树，插入黑结点左根       
    2. 插入红结点，父亲结点是黑结点，满足规则          
    3. 插入红结点，父亲结点是红结点，违反规则                
    这里假设父亲结点是爷爷结点的左子树来进行处理：                       

    1. 父亲是红结点，叔叔也是存在，并且叔叔也是红结点                   
        处理方法：将叔叔和父亲都改为黑结点，并且将爷爷改成红结点，再将爷爷当做新插入的结点进行判断                
        对于爷爷，如果是根节点，不在进行向上判断，否则进行向上判断：                    
        1. 如果爷爷是根节点，直接将爷爷结点的颜色改变成黑色                
        2. 为什么要将爷爷当做新插入的结点进行判断呢？                
        因为有可能爷爷的父亲也是红结点，所以需要再次向上进行改变结点的颜色              
    2. 父亲是红结点，叔叔结点不存在或者叔叔结点是黑结点，插入的结点，是一个方向的，也就是插入的结点是父亲的左子树                   
    处理方法：将父亲结点改为黑色，将爷爷结点改为红色，然后以爷爷结点为支点，进行右单旋                         
    3. 父亲是红结点，叔叔结点不存在或者叔叔结点是黑结点，插入的结点，不是一个方向的，也就是插入的结点是父亲的右子树                   
    处理方法：将父亲结点改为黑色，然后以父亲结点为支点，进行左单旋；随后将爷爷结点改为红色，然后以爷爷结点为支点进行右单旋即可                  
                            
如何判断是否是红黑树？                
    对于如何判断是否是红黑树，需要判断的是红黑树的三个条件：              
    1. 对于根节点必须是黑色          
    2. 不能存在连续的红色结点             
    3. 对于从任意一个结点开始的每一条路径上的黑色结点都应该是一样多的            
        对于第三个来说，我们可以直接来判断从根节点到每一个叶子节点的黑色结点的数量是不是一样多的就可以了              
        因为只要根节点满足了之后，其他的结点的路径上的黑色结点的个数一定是一样多的                



